{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Important</p> <ul> <li>This project is still a work in progress, so expect some bugs! If you encounter any, please open an issue or submit a PR with a fix.</li> <li>This suite has been ported from the <code>tello_suite</code> project, so some names may not have been fully updated to reflect the new <code>robot_...</code> naming convention.</li> </ul> <p>Robot Suite is a collection of ROS2 packages designed to enhance the capabilities of robots, making them smarter and more versatile. The suite utilizes a series of plugins\u2014ROS2 packages with specialized features\u2014to extend the robot's functionality. While each plugin can operate independently, the primary goal of the suite is to integrate with the robot_bt package, which enables complex behaviors by orchestrating the execution of multiple plugins.</p> <p>A key principle of this project is robot agnosticism. This means that the combination of these plugin packages is designed to work across any robot platform, including both ground and aerial robots. As such, there is no robot-specific package, such as a dedicated robot driver. Instead, we leverage ROS' standard interfaces, using middleware and configuration files to ensure compatibility. For instance, these configuration files allow plugins to subscribe to the appropriate topics for the robot in use.</p> <p>The suite also includes a Dockerfile for easy setup, eliminating the need to install dependencies on your computer and simplifying the process of switching between different robot platforms. For more information, refer to the Docker page.</p>"},{"location":"GettingStarted/contribute/","title":"Contributing Guide","text":"<p>Thank you for considering contributing to our project! This guide will help you understand the contribution workflow and best practices to follow.</p>"},{"location":"GettingStarted/contribute/#forking-the-repository","title":"Forking the Repository","text":"<p>To start contributing, first fork the repository:</p> <ol> <li>Visit the project repository on GitHub.</li> <li> <p>Click the Fork button in the top-right corner of the page. Refer to the example screenshot below:</p> <p></p> </li> </ol> <p>This will create a copy of the repository under your GitHub account.</p>"},{"location":"GettingStarted/contribute/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Once you've forked the repository, clone it to your local machine:</p> <pre><code># Replace 'username' with your GitHub username\ngit clone git@github.com:username/tello_suite.git\n</code></pre> <p>This will download the repository to your local system.</p>"},{"location":"GettingStarted/contribute/#setting-up-a-new-branch","title":"Setting Up a New Branch","text":"<p>Before starting work on a new feature or bug fix, create a new branch to keep your changes organized. Use a descriptive branch name based on the work you\u2019re doing. For example, if you\u2019re adding a new plugin for interacting with a large language model (LLM), you might use a branch name like <code>feat/llm_plugin</code>.</p>"},{"location":"GettingStarted/contribute/#workflow-example","title":"Workflow Example","text":"<p>Here\u2019s an example of a typical workflow:</p> <pre><code>cd tello_suite\n\ngit checkout -b feat/llm_plugin # Create and switch to a new branch\n\n# Make changes to your code\n\ngit add &lt;files&gt; # Stage your changes\ngit commit -m \"A short and descriptive commit message\" # Commit your changes\n\ngit push -u origin feat/llm_plugin # Push the branch to your fork and set up tracking\n</code></pre>"},{"location":"GettingStarted/contribute/#tips-for-commit-messages","title":"Tips for Commit Messages","text":"<ul> <li>Use clear and concise messages.</li> <li>Begin with a verb in the imperative mood (e.g., \"Add,\" \"Fix,\" \"Update\").</li> <li>Keep the message short but descriptive.</li> </ul>"},{"location":"GettingStarted/contribute/#submitting-your-changes","title":"Submitting Your Changes","text":"<p>After completing your changes and pushing them to your branch, create a pull request (PR):</p> <ol> <li>Go to your forked repository on GitHub.</li> <li>Navigate to the branch you worked on.</li> <li>Click the Pull Request button.</li> <li>Fill out the PR template (if provided) and add a clear description of your changes.</li> <li>Submit the PR for review.</li> </ol> <p>Your PR will be reviewed by maintainers, and you may be asked to make some changes before it is merged.</p> <p>Thank you for contributing! Your efforts make this project better for everyone.</p>"},{"location":"GettingStarted/docker/","title":"\ud83d\udc33 Docker","text":"<p>For this project, we are making use of Docker Compose to ease the build and start of containers. The <code>docker-compose.yml</code> file is/will be composed of services, where each service is targeted for each robot platform.</p> <p>This project uses Docker Compose to simplify building and running containers for different robot platforms.</p> <p>The main configuration file is <code>docker-compose.yml</code>, which defines a separate service for each supported robot platform.</p> <p>Note</p> <p>Currently, only the Tello robot platform is supported.</p>"},{"location":"GettingStarted/docker/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Important</p> <p>If you want to use GUI applications inside Docker (e.g., visual tools like RViz), run the following command once before starting any containers:</p> <pre><code>xhost +local:docker\n</code></pre>"},{"location":"GettingStarted/docker/#using-docker-compose-recommended","title":"Using Docker Compose (Recommended)","text":"<p>Info</p> <p>Note that you will need to have <code>docker-compose</code> installed on your system. You can check if it is installed by running <code>docker-compose -v</code>. On ubuntu, you can install it using <code>sudo apt install docker-compose</code></p> <p>Make sure you have docker-compose installed. You can check with:</p> <pre><code>docker-compose -v\n</code></pre> <p>On Ubuntu, install it using:</p> <pre><code>sudo apt install docker-compose\n</code></pre> <p>Steps:</p> <ol> <li> <p>Open a terminal and navigate to the root directory of the project.</p> </li> <li> <p>Run the following command (replace  with the desired platform):    docker compose up _suite <p>Available Platforms</p> <ul> <li>tello:     <pre><code>docker compose up tello_suite\n</code></pre></li> </ul>"},{"location":"GettingStarted/docker/#manual-docker-usage-advanced","title":"Manual Docker Usage (Advanced)","text":"<p>If you prefer not to use Docker Compose, you can build and run the containers manually.</p> <p>Each robot platform has its own <code>Dockerfile</code> located at: <code>docker/&lt;robot_platform&gt;/Dockerfile</code></p> <p>Tip</p> <p>Replace  with one of the supported platforms: <ul> <li>tello</li> </ul> <p>Steps:</p> <ul> <li> <p>Go to the root of the project.</p> </li> <li> <p>Build the Docker image:</p> </li> </ul> <pre><code>docker build -t &lt;robot_platform&gt;_suite -f docker/&lt;robot_platform&gt;/Dockerfile .\n</code></pre> <ul> <li>Run the container and launch the robot system (recommended):</li> </ul> <pre><code>docker run --rm -it \\\n    -v /tmp/.X11-unix:/tmp/.X11-unix \\\n    -e DISPLAY=$DISPLAY \\\n    --net=host \\\n    &lt;robot_platform&gt;_suite \\\n    ros2 launch &lt;robot_package&gt; system_launch.py\n</code></pre> <ul> <li>Or start the container with a terminal session:</li> </ul> <pre><code>docker run --rm -it \\\n    -v /tmp/.X11-unix:/tmp/.X11-unix \\\n    -e DISPLAY=$DISPLAY \\\n    --net=host \\\n    &lt;robot_platform&gt;_suite \\\n</code></pre> <p>Example for Tello Platform</p> <pre><code># Step 1: Build the Docker image\ndocker build -t tello_suite -f docker/tello/Dockerfile .\n\n# Step 2: Enable GUI support\nxhost +local:docker\n\n# Step 3: Launch the system inside the container\ndocker run --rm -it \\\n    -v /tmp/.X11-unix:/tmp/.X11-unix \\\n    -e DISPLAY=$DISPLAY \\\n    --net=host \\\n    tello_suite \\\n    ros2 launch tello_bringup system_launch.py\n</code></pre>"},{"location":"GettingStarted/installation/","title":"Installation","text":""},{"location":"GettingStarted/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>ROS2 Humble or later (only tested with Humble)</li> <li>Ubuntu 22.04</li> </ul>"},{"location":"GettingStarted/installation/#automatic-installation-recommended","title":"Automatic Installation (Recommended)","text":"<p>A script is provided to automatically install all dependencies and setup the workspace. The robot type needs to be specified as an argument to the script. The available options are:</p> <ul> <li><code>tello</code>: for the Tello drone</li> <li><code>spot</code>: for the Spot robot (Not yet supported)</li> <li><code>unitree_go1</code>: for the Unitree Go1 robot (Not yet supported)</li> </ul> <pre><code>sudo ./bootstrap.sh [robot]\n</code></pre> <p>Running the script</p> <p>Make sure to run the script with <code>sudo</code>.</p>"},{"location":"GettingStarted/installation/#manual-installation","title":"Manual Installation","text":"<p>If you prefer to install the dependencies manually, you will first need to ensure your robot driver is installed properly. Additionally, pip packages are required which can be found in the <code>requirements.txt</code> file. You can install them using the following command:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>For ros dependencies, you can use the following command:</p> <pre><code>rosdep install --from-paths . -r -y\n</code></pre>"},{"location":"Packages/robot_bringup/","title":"Robot Bringup","text":"<p>Note</p> <p>To be done!</p>"},{"location":"Packages/robot_bt/","title":"Robot Behavior Tree","text":"<p>The <code>robot_bt</code> package implements a behavior tree (BT) for managing and executing plugins that define various behaviors for the robot. This package uses the <code>py-trees</code> library to structure and run the behavior tree.</p>"},{"location":"Packages/robot_bt/#what-is-a-behavior-tree","title":"What is a Behavior Tree?","text":"<p>A behavior tree is a model that organizes defined behaviors into a tree structure, allowing them to be executed (or \"ticked\") in each iteration. While similar to a Finite State Machine (FSM), a behavior tree supports more complex scenarios with greater flexibility and simplicity.</p> <p>In <code>py_trees</code>, a behavior tree is built using nodes, decorators, and composites, each with specific functionality to control the flow of execution. For more information, visit py_trees documentation</p>"},{"location":"Packages/robot_bt/#common-nodes-used","title":"Common Nodes Used","text":""},{"location":"Packages/robot_bt/#action-nodes","title":"Action Nodes","text":"<p>Action nodes perform specific tasks when ticked. They execute actions and return a status (<code>SUCCESS</code>, <code>FAILURE</code>, or <code>RUNNING</code>).</p> <ul> <li><code>py_trees.behaviour.Behaviour</code>: The base class for any node you desire to create which does not require ROS.</li> <li><code>robot_bt.nodes.actions.Action</code>: The base class for any node you desire to create which relies on ROS.</li> <li><code>robot_bt.nodes.PluginClient</code>: A node which is used to execute a plugin.</li> </ul>"},{"location":"Packages/robot_bt/#condition-nodes","title":"Condition Nodes","text":"<ul> <li><code>robot_bt.nodes.conditionals.CanRunPlugin</code>: A conditional node which can be used to check if a plugin is currently selected to run.</li> </ul> <p>Condition nodes check a condition and return <code>SUCCESS</code> if it is met, otherwise <code>FAILURE</code>.</p>"},{"location":"Packages/robot_bt/#common-decorators-used","title":"Common Decorators Used","text":"<p>Decorators modify the behavior of their child node based on specific rules or conditions.</p> <ul> <li><code>py_trees.decorators.Inverter</code>: Inverts the result of the child node (e.g., <code>SUCCESS</code> becomes <code>FAILURE</code>).</li> </ul>"},{"location":"Packages/robot_bt/#common-composites-used","title":"Common Composites Used","text":"<p>Composite nodes are used to group multiple child nodes and control their execution flow.</p> <ul> <li> <p><code>py_trees.composites.Sequence</code>: Executes its children in order until one fails. Returns:</p> <ul> <li><code>SUCCESS</code> if all children succeed.</li> <li><code>FAILURE</code> if any child fails.</li> <li><code>RUNNING</code> if a child is still running.</li> </ul> </li> <li> <p><code>py_trees.composites.Selector</code>: Executes its children in order until one succeeds. Returns:</p> <ul> <li><code>SUCCESS</code> if any child succeeds.</li> <li><code>FAILURE</code> if all children fail.</li> <li><code>RUNNING</code> if a child is still running.</li> </ul> </li> <li> <p><code>py_trees.composites.Parallel</code>: Executes all children simultaneously. Returns:</p> <ul> <li><code>SUCCESS</code> if the required number of children succeed.</li> <li><code>FAILURE</code> if too many children fail or if required conditions are not met.</li> </ul> </li> </ul>"},{"location":"Packages/robot_bt/#creating-a-behavior-tree","title":"Creating a Behavior Tree","text":"<p>By default, the behavior tree used is <code>robot_bt.bt.DefaultBT</code>. To create your own custom behavior tree, follow these steps:</p> <ol> <li>Create a New File: Add a new Python file in the <code>robot_bt.bt</code> directory and name it appropriately.</li> <li>Define the <code>bootstrap</code> Function:<ul> <li>Your file must define a function named <code>bootstrap(ros_node: rclpy.Node) -&gt; py_trees.behaviour.Behaviour</code>.<ul> <li>This function will be called by the BT ROS node to load your behavior tree.</li> <li>It should return the root of your tree.</li> </ul> </li> </ul> </li> <li>Update Parameters: Modify the parameter file to set the <code>bt_name</code> field to your file name (without the <code>.py</code> extension).</li> </ol>"},{"location":"Packages/robot_bt/#example","title":"Example","text":"<p>Example</p> <p>Python Code</p> robot_bt/bt/simple_bt.py<pre><code>import py_trees\nfrom rclpy.node import Node\n\ndef create_tree(): # Leaf nodes\n    success_node = py_trees.behaviours.Success(name=\"Always Succeed\")\n    failure_node = py_trees.behaviours.Failure(name=\"Always Fail\")\n\n    # Decorator\n    invert_failure = py_trees.decorators.Inverter(child=failure_node)\n\n    # Composite\n    sequence = py_trees.composites.Sequence(name=\"Simple Sequence\")\n    sequence.add_children([success_node, invert_failure])\n\n    return sequence\n\ndef bootstrap(ros_node: Node) -&gt; py_trees.behavior.Behaviour:\n    tree = create_tree()\n    return tree\n</code></pre> <p>Parameters File</p> config/params.yaml<pre><code>bt_server:\n    ros__parameters:\n        bt_name: simple_bt\n</code></pre>"},{"location":"Packages/robot_bt/#explaining-default-bt","title":"Explaining Default BT","text":"<p>Below is the graphical representation of the <code>DefaultBT</code> behavior tree.</p> <p>Note</p> <ul> <li>Reactive sequence is a sequence without memory, meaning that it will always start from the first child.</li> <li>Sequence has memory, meaning if one of it's children returns <code>RUNNING</code>, the next time it ticks, it will tick directly that child.</li> </ul> <p></p> <p>The structure and purpose of each part of the tree are as follows:</p>"},{"location":"Packages/robot_bt/#root-defaultbt","title":"Root: <code>DefaultBT</code>","text":"<ul> <li>Type: Sequence (no memory)</li> <li>Purpose: Ensures all the children (subsystems) are checked or executed in order.</li> </ul>"},{"location":"Packages/robot_bt/#1-drone-connection-checker","title":"1. Drone Connection Checker","text":"<ul> <li>Type: Selector (no memory)</li> <li>Child: <code>IsDroneConnected</code></li> <li>Purpose: Verifies if the drone is connected.<ul> <li>If the connection is successful (<code>SUCCESS</code>), it moves to the next step.</li> <li>If the connection is not established (<code>FAILURE</code>), the tree stops ticking and the sequence fails.</li> </ul> </li> </ul>"},{"location":"Packages/robot_bt/#2-battery-checker","title":"2. Battery Checker","text":"<ul> <li>Type: Selector (no memory)</li> <li>Children:<ul> <li><code>IsBatteryLow</code>: Checks if the battery is low. If it is, returns <code>SUCCESS</code>.</li> <li>Inverter (decorator) \u2192 <code>LandAction</code>: If the battery is not low, the decorator inverts the result of the <code>LandAction</code>.<ul> <li>The <code>LandAction</code> would normally return <code>FAILURE</code> (since landing is not required when the battery is okay), but the <code>Inverter</code> converts it to <code>SUCCESS</code>.</li> </ul> </li> </ul> </li> <li>Purpose: Ensures that if the battery is low, the drone lands safely. Otherwise, it allows the behavior tree to continue execution.</li> </ul>"},{"location":"Packages/robot_bt/#3-remote-operator","title":"3. Remote Operator","text":"<ul> <li>Type: Action Node</li> <li>Name: <code>RemoteOperator</code></li> <li>Purpose: Checks keyboard input from <code>robot_control_station</code> and change selected plugin from blackboard to hand gestures plugin if selected.<ul> <li>Alawas returns <code>SUCCESS</code></li> </ul> </li> </ul>"},{"location":"Packages/robot_bt/#4-plugins-selector","title":"4. Plugins Selector","text":"<ul> <li>Type: Selector (no memory)</li> <li> <p>Children:</p> <ol> <li>Hand Gestures Control (no memory):<ul> <li><code>CanRunPlugin</code>: Checks if the \"landmark_detector_node\" plugin is enabled and can run.</li> <li><code>PluginClient</code>: Executes the plugin responsible for hand gesture control, enabling drone interaction using visual gestures.</li> </ul> </li> </ol> </li> <li> <p>Purpose: Extends the drone's capabilities by enabling additional plugins, such as gesture control. If no plugin is active or available, this branch fails, but the rest of the tree can continue.</p> </li> </ul> <p>Example</p> robot_bt/bt/default_bt.py<pre><code># ...\nclass DefaultBT(py_trees.composites.Sequence):\n    # ...\n    def build_tree(self):\n        drone_connection = py_trees.composites.Selector(\n            \"DroneConnection\",\n            memory=False,\n            children=[\n                IsDroneConnected(\"IsDroneConnected\"),\n            ],\n        )\n\n        battery_checker = py_trees.composites.Selector(\n            \"BatteryChecker\",\n            memory=False,\n            children=[\n                IsBatteryLow(\"IsBatteryLow\", self.node),\n                py_trees.decorators.Inverter(\n                    \"LandActionInverter\", LandAction(\"LandAction\", self.node)\n                ),\n            ],\n        )\n\n        remote_operator = RemoteOperator(\"RemoteOperator\", self.node)\n\n        plugins = py_trees.composites.Selector(\n            \"Plugins\",\n            memory=False,\n            children=[\n                py_trees.composites.Sequence(\n                    \"HandGesturesControl\",\n                    memory=False,\n                    children=[\n                        CanRunPlugin(\"CanRunHandGestures\", \"landmark_detector_node\"),\n                        PluginClient(\n                            \"HandGesturesPlugin\", \"landmark_detector_node\", self.node\n                        ),\n                    ],\n                )\n            ],\n        )\n\n        self.add_children([drone_connection, battery_checker, remote_operator, plugins])\n\n\ndef bootstrap(ros_node: Node) -&gt; py_trees.behaviour.Behaviour:\n    return DefaultBT(ros_node)\n</code></pre>"},{"location":"Packages/tello_control_station/","title":"Tello Control Station","text":"<p>Warning</p> <p>This is a legacy package that will be replaced by possibly a web application. It is a UI package running with pygame. It is very limited and not well designed.</p>"},{"location":"Plugins/","title":"About Plugins","text":"<p>What is a plugin, you may ask? Simply put, a plugin is a ROS2 package designed to add new functionality that doesn't need to run constantly, unlike the <code>tello_driver</code>. Plugins are optional components that can be dynamically controlled by the behavior tree (<code>robot_bt</code>), enabling flexible and modular task execution.</p> <p>The core idea of plugins is their ability to work together seamlessly, allowing for different types of functionality to be combined to achieve complex tasks. For example:</p> <ul> <li>A default plugin shipped with the system is a hand gesture detector, which interprets gestures and converts them into drone commands.</li> <li>Another example could be a person follower plugin, where the drone autonomously tracks and follows a person.</li> </ul> <p>In the future, the selection of which plugin to run can be configured using a behavior tree and a configuration file, making the system even more adaptable.</p>"},{"location":"Plugins/#how-to-create-a-plugin","title":"How To Create a Plugin","text":"<p>As mentioned, a plugin is just a ROS2 package. You can create a new package under the <code>plugins</code> folder or import your own pre-existing package.</p> <p>When developing your plugin, you need to use the plugin_base package. This package provides a base class (<code>PluginNode</code>) for implementing plugins. Check the Getting Started Section for more details on how to use it.</p>"},{"location":"Plugins/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>Does my plugin need to have all its nodes based on <code>PluginNode</code>?</p> <p>No. If you have a main node that handles input and produces output, and your other nodes depend on its data, you do not need to base all nodes on <code>PluginNode</code>. Only the node interacting with the behavior tree (<code>robot_bt</code>) requires this.</p> <p>When does my node strictly require the use of <code>PluginNode</code>?</p> <p>If you want your node to be controlled by the behavior tree (<code>robot_bt</code>), you must base it on <code>PluginNode</code>. This ensures compatibility and control integration.</p>"},{"location":"Plugins/hand_gestures/","title":"Hand Gestures Plugin","text":"<p>This plugin aims to detect hand landmarks and interpret the landmarks to gestures. These gestures can then be used to control a robot movement for instance.</p>"},{"location":"Plugins/hand_gestures/#standalone-usage","title":"\ud83d\ude80 Standalone Usage","text":"<p>Note</p> <p>Each command needs to be executed in 2 different terminals and you must source the <code>install/setup.bash</code> which was created in the section above.</p> <ol> <li>Launch the detector node in standalone mode</li> </ol> <pre><code> ros2 run hand_gestures landmark_detector_node --ros-args -p standalone:=true\n</code></pre> <ol> <li>Launch the annotator node in standalone mode</li> </ol> <pre><code> ros2 run hand_gestures landmark_annotator_node --ros-args -p standalone:=true\n</code></pre>"},{"location":"Plugins/hand_gestures/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>This plugin is composed of 2 main nodes: <code>landmark_detector_node</code> and <code>landmark_annotator_node</code>. Landmark detector node is responsible for detecting hand landmarks in images and publishing both the landmarks and the recognized gestures. The landmark annotator node is responsible for drawing the detected landmarks on the image and publishing the annotated image.</p>"},{"location":"Plugins/hand_gestures/#ros-related","title":"\ud83e\udd16 ROS Related","text":""},{"location":"Plugins/hand_gestures/#subscribed-topics","title":"\ud83d\udce5 Subscribed Topics","text":""},{"location":"Plugins/hand_gestures/#landmark-detector-node","title":"Landmark Detector Node","text":"Topic Name Message Type Description <code>/camera/image_raw</code> sensor_msgs/Image) Input image for hand detection."},{"location":"Plugins/hand_gestures/#landmark-annotator-node","title":"Landmark Annotator Node","text":"Topic Name Message Type Description <code>/camera/image_raw</code> sensor_msgs/Image Input image use for hand detection. <code>/hand/landmarks</code> hand_gestures_msgs/Landmakrs Landmarks detected."},{"location":"Plugins/hand_gestures/#published-topics","title":"\ud83d\udce4 Published Topics","text":""},{"location":"Plugins/hand_gestures/#landmark-detector-node_1","title":"Landmark Detector Node","text":"Topic Name Message Type Description <code>/hand/landmarks</code> hand_gestures_msgs/Landmakrs) Output landmarks topic for detected hands."},{"location":"Plugins/hand_gestures/#landmark-annotator-node_1","title":"Landmark Annotator Node","text":"Topic Name Message Type Description <code>/hand/annotated/image</code> sensor_msgs/Image) Annotated image with landmarks for detected hands."},{"location":"Plugins/hand_gestures/#parameters","title":"\u2699\ufe0f Parameters","text":""},{"location":"Plugins/hand_gestures/#landmark-detector-node_2","title":"Landmark Detector Node","text":"Parameter Name Description Default <code>img_input_topic</code> Input image topic name. <code>/camera/image_raw</code> <code>landmarks_topic</code> Detected landmarks on image. <code>hand/landmarks</code> <code>num_hands</code> Maximum number of hands to detect. 2 <code>min_detection_confidence</code> Minimum confidence to detect a hand. 0.5 <code>min_tracking_confidence</code> Minimum confidence to track a hand. 0.5"},{"location":"Plugins/hand_gestures/#landmark-annotator-node_2","title":"Landmark Annotator Node","text":"Parameter Name Description Default <code>img_input_topic</code> Input image topic name. <code>/camera/image_raw</code> <code>annotated_img_topic</code> Annotated image with landmarks topic name. <code>/camera/image_raw</code> <code>landmarks_topic</code> Detected landmarks on image. <code>hand/landmarks</code>"},{"location":"Plugins/plugin_base/","title":"Plugin Base","text":"<p>The <code>plugin_base</code> package serves as a bridge between the <code>robot_bt</code> framework and any custom plugins you create. It allows you to develop plugins independently, without requiring direct use of <code>robot_bt</code> or the <code>py-trees</code> library (which manages the behavior tree).</p> <p>Essentially, this package provides a ROS 2 node with a pre-configured ROS 2 service, enabling the behavior tree to trigger the execution (or \"ticking\") of your plugin.</p>"},{"location":"Plugins/plugin_base/#getting-started","title":"Getting Started","text":"<p>Using this package is straightforward and requires only two steps:</p> <ol> <li>Inherit from <code>plugin_base.PluginNode</code>: Use this as the base class for your node instead of <code>rclpy.Node</code>.</li> <li>Define the <code>tick(self)</code> method: Implement the <code>tick()</code> method in your node class. This method is essential; it will serve as the main loop for your plugin.</li> </ol> <p>Danger</p> <p>You must implement the <code>tick</code> function. You can think of it as an inifite while loop. This function should not contain any inifinte loop inside!!</p> <p>Example</p> <pre><code>from plugin_base.plugin_base import PluginNode\nfrom typing import Optional, Any\n\nclass MyNode(PluginNode):\n  def __init__(self, node_name: str):\n    super().__init__(node_name)\n\n    # ...\n\n  def tick(self, blackboard: Optional[dict[\"str\", Any]] = None):\n    # Implement here the logic\n    pass\n</code></pre>"},{"location":"Plugins/plugin_base/#parameters","title":"Parameters","text":"<p>The following parameters can be configured in the <code>plugin_base</code> package:</p> Parameter Name Default Value Description <code>tick_rate</code> 30 When in standalone mode, this parameter sets the rate (in Hz) at which the <code>tick()</code> method is called. <code>standalone</code> false If set to <code>true</code>, the plugin runs in standalone mode, meaning it operates without the behavior tree."},{"location":"Plugins/plugin_base/#for-developers","title":"For developers","text":"<p>We offer a simple plugin tester node, which is targeted for developers to test for example their behavior tree. The node name is <code>test_plugin_node</code> and it can be executed with:</p> <pre><code>ros2 run plugin_base test_plugin\n</code></pre> <p>Tip</p> <p>In case you want to test your plugin while in development, you can run it in standalone mode. In order to use the plugin in standalone mode, you can run the following command:</p> <pre><code>ros2 run plugin_server_base test_plugin --ros-args -p standalone:=true -p tick_rate:=30\n</code></pre>"}]}